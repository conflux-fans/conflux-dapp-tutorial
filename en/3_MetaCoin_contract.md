# MetaCoin contract

Conflux Network uses EVM as its virtual machine. Users can develop smart contracts using Solidity similarly to Ethereum.

Solidity is an Object-Oriented high-level smart contract development language that supports inheritance. Solidity is a statically-typed language.

Smart contracts are programs used to manage the behaviors of accounts in the Conflux Network state.  Contracts can be implemented for many applications such as voting, crowdfunding, multi-signature wallets, etc.

Currently, various ERC20 tokens, Defi projects, NFTs, and Dexes in the Ethereum Network are developed using Solidity. Therefore, it is the best choice to learn Solidity when developing Dapps.

## Blockchain Basics

### Transaction

Blockchain is a globally shared database of transactions. Anyone can read the data from the network. Users can only modify the state of the database by sending a transaction. That transaction will be recorded on the ledger and will have an impact on the data or state of the database if it is accepted by everyone in the network. As implied by the word "Transaction", the data state changes by the transaction will either all succeed or none of them will take effect (Fail).

A Transaction is a `message` sent from one account to another (can be empty).  Users can specify the amount of transferred CFX, or add some binary data (payload) to the `message`.

If the target account contains smart contract code, then the code will be executed and the payload will be used as the input data of sponsorring.

If the target account is empty or null, then a new contract account will be created by the code of the payload in this transaction. The new contract's address will be generated based on the sender's address and the nonce of the transaction. (The address generation rules for Conflux contracts also include the contract code.)

### Block

Transactions will be packed into a block. Blocks are sequentially linked to each other. The sequence will determine the order of transactions and prevent the so-called double spending attack. Blocks will be packed and generated by miners at a fixed speed. The average time for creating blocks is 17s on Ethereum while it is 0.5s on Conflux.

### Account

There are two types of accounts sharing the same address space on Ethereum or Conflux:

* External Accounts
* Contract Accounts

The differences between the two accounts are outlined below:

| Account Type   | Have Code | Controlled by | Address generation rule |
| --------- | ----------| ---------| ----------|
| External Account   | No        | Public-private key pair  | By public key  |
| Contract Account   | Yes       | Account code  | determined by the address of the external account that created the contract and its nonce |

In addition, both accounts have permanent storage space(map) for the key-value. Both key and value are 256 bits and both accounts can have a CFX balance.

**To summarise, a smart contract is a piece of code that manages the state of an EVM account, which is stored in the corresponding EVM account.**

We can understand the essence of a smart contract through an example of a Solidity contractï¼š

```js
// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.4.16 <0.9.0;

contract SimpleStorage {
    uint storedData;  // The contract's state

    function set(uint x) public {  // Update contracts's state
        storedData = x;
    }

    function get() public view returns (uint) { // Read contract's state
        return storedData;
    }
}
```

It is a simple Solidity smart contract above:

* It defines a variable (state) called `storedData` by the type of uint, which is stored in the key-value storage of the contract account.
* A read method `get`, which reads the state of the contract (and returns the value of storedData).
* A write method `set`, which modifies the state of the contract (and updates the value of storedData)

There are a few more things that need to be done before running this code:

1. Compile the code with the Solidity compiler to get the ByteCode and ABI of that contract.
2. Send a transaction using an external account to create the contract account. The receiving address of the transaction should be set to `null` . After the transaction is packed and executed by the blockchain, the Receipt of the transaction can be queried, which contains the address of the newly created contract account.
3. The contract code can be called by sending a message (tx) to the contract account using an external account. Users can query or update the status of the contract in this way. In this case, the receiving address of the transaction should be set to the contract account address, and the payload of the transaction should contain the ID and parameters (Usually generated using ABI) of the method that you want to call. If it is a status reading operation, the transaction will be sent directly to the EVM by `eth_call/cfx_call` method for execution and then the result will be returned. This transaction does not need to be packed on-chain. If it is a contract status updating operation, the transaction needs to be signed and sent on-chain by `sendRawTransaction` for packaging and execution.

For more details of the blockchain and EVM concepts, please read [Introduction to smart contracts by Solidity](https://docs.soliditylang.org/en/v0.8.10/introduction-to-smart-contracts.html)

## Solidity Contract Example

Now let's take a look at a little more complicated example: Subcurrency. It implements a cryptocurrency that only allows the creator to issue new currencies, but anyone can send their Coin to others by sending transactions without any restriction.

```js
//SPDX-License-Identifier: MIT
pragma solidity ^0.7.0;

contract MetaCoin {
    // An `address` is comparable to an email address - it's used to identify an account on Conflux.
    // Addresses can represent a smart contract or an external (user) accounts.
    // Learn more: https://solidity.readthedocs.io/en/v0.5.10/types.html#address
    address public owner;

    // A `mapping` is essentially a hash table data structure.
    // This `mapping` assigns an unsigned integer (the token balance) to an address (the token holder).
    // Learn more: https://solidity.readthedocs.io/en/v0.5.10/types.html#mapping-types
    mapping (address => uint) private balances;

    // Events allow for logging of activity on the blockchain.
    // Conflux clients can listen for events in order to react to contract state changes.
    // Learn more: https://solidity.readthedocs.io/en/v0.5.10/contracts.html#events
    event Transfer(address from, address to, uint amount);

    // Initializes the contract's data, setting the `owner`
    // to the address of the contract creator.
    constructor() {
        // All smart contracts rely on external transactions to trigger its functions.
        // `msg` is a global variable that includes relevant data on the given transaction,
        // such as the address of the sender and the CFX value included in the transaction.
        // Learn more: https://solidity.readthedocs.io/en/v0.5.10/units-and-global-variables.html#block-and-transaction-properties
        owner = msg.sender;
    }

    // Creates an amount of new tokens and sends them to an address.
    function mint(address receiver, uint amount) public {
        // `require` is a control structure used to enforce certain conditions.
        // If a `require` statement evaluates to `false`, an exception is triggered,
        // which reverts all changes made to the state during the current call.
        // Learn more: https://solidity.readthedocs.io/en/v0.5.10/control-structures.html#error-handling-assert-require-revert-and-exceptions

        // Only the contract owner can call this function
        require(msg.sender == owner, "You are not the owner.");

        // Ensures a maximum amount of tokens
        require(amount < 1e60, "Maximum issuance succeeded");

        // Increases the balance of `receiver` by `amount`
        balances[receiver] += amount;
    }

    // Sends an amount of existing tokens from any caller to an address.
    function transfer(address receiver, uint amount) public {
        // The sender must have enough tokens to send
        require(amount <= balances[msg.sender], "Insufficient balance.");

        // Adjusts token balances of the two addresses
        balances[msg.sender] -= amount;
        balances[receiver] += amount;

        // Emits the event defined earlier
        emit Transfer(msg.sender, receiver, amount);
    }

    // Query balance of one account
    function balanceOf(address account) public view returns (uint) {
        return balances[account];
    }

    // Enable anyone claim 100 MetaCoin from faucet
    function faucet() public {
        balances[msg.sender] += 100;
    }
}
```

1. The first and second lines of the code declare the code's license and the version of Solidity.
2. Then a contract class `MetaCoin` is declared using the keyword contract
3. The MetaCoin contract defines two properties (state variables): `owner`, `balances`
4. The MetaCoin contract also defines four methods: `constructor`, `mint`, `transfer`, `faucet`
5. The MetaCoin contract also defines an event: `Transfer` , which is used to record all transfer events.
6. The MetaCoin contract also defines a query method: `balanceOf` , which is used to query the user's MetaCoin balance.

Above is the basic structure of a contract. For more details about Solidity: data types, expressions, controls, functions, etc., see the [Language Description](https://docs.soliditylang.org/en/v0.8.10/layout-of-source-files.html) of Solidity.

### Compiler

Once the Solidity contract is finished, it needs to be compiled with a compiler to get the ByteCode before being deployed. There are many Solidity compilers (tools) : 

* The native Solidity compiler is developed in C++. Users can download the [compiler directly](https://docs.soliditylang.org/en/v0.8.10/installing-solidity.html#linux-packages) or [compile it from the source code by themselves]((https://docs.soliditylang.org/en/v0.8.10/installing-solidity.html#building-from-source)).
* `npm` provides a more convenient way to install: `npm install -g solc`. The `solc` installed in this way has some differences from the native compiler, see the [solcjs](https://github.com/ethereum/solc-js) documents for details.
* [Remix](https://remix.ethereum.org/) is an online IDE for developing and compiling small contracts and learning Solidity quickly. [ChainIDE](https://chainide.com/) is similar to Remix and supports deployment directly to the Conflux Network.
* [Truffle](https://trufflesuite.com/truffle/) and [Hardhat](https://hardhat.org/) are two powerful Solidity development environments used by many developers today. They can not only compile contracts, but also provide fast deploying, testing, debugging, and a large number of plugins for various features.

Once the compiler is installed, you can use it to compile Solidity contracts:

```shell
$ solc -o outputDirectory --bin --ast-compact-json --asm sourceFile.sol
```

For more information on how to use solc, please refer to the [official solc documentation](https://docs.soliditylang.org/en/v0.8.10/using-the-compiler.html#commandline-compiler).

### ChainIDE

[ChainIDE](https://chainide.com/) is an online Solidity development environment. It supports multiple chains: Ethereum, BSC, Conflux, and more. Here we use it to demonstrate the development, deployment, and interaction of contracts. It is easy to use ChainIDE in the browser, this way you do not need to install anything. It also supports logging in with a Github account. All projects created can be saved on the cloud.

After entering the [dashboard](https://chainide.com/s/dashboard) page, you can see all projects of the current user. Just click Add to check all the supported contract project templates for each chain that ChainIDE supports. First of all,  select Conflux on the left, and then select one from the templates provided on the right to create a Solidity project.

![](../images/chainide/template.png)

Once the project is created, you will see the workspace page of the project. Since the deployment and interaction of the contract need to be done through the wallet extension, when the workspace page is opened, ChainIDE will request a connection to the wallet account. It will require authorization for the user.

![](../images/chainide/workspace-intro.jpeg)

The page is similar to the developer's tools:

* The first column on the left has several buttons or links. From top to bottom: Back to the dashboard, Project files, Plugins.
* The second column is the file browser, where you can manage (view, create, delete, rename) the files in the current project.
* The third column is the code editing area and the result output area.
* The fourth column is the plug-in area. We can use the buttons on the right edge to switch. Currently, there are three plug-ins: Compiler, Deploy & interaction, and Transaction
* The status bar is on the bottom. It shows the current network, users, balance and other information on the right.

We can create a new contract file in the file browser of the work area, and edit the code in the code editing area. After the code development is finished, we can use the Compiler plugin to compile it. Here we use the code of the `MetaCoin` contract. Then the plug-in will automatically select the corresponding version of the compiler according to the `pragma` statement of the code. Now click the Compile button to start. The ABI and Bytecode of the contract will be displayed after compilation.

![](../images/chainide/compiler.jpeg)

Developers can copy ABI and Bytecode for SDKs to deploy contracts, or directly use ChainIDE's Deploy & Interaction plugin. After switching to the Deploy plugin, you can select the contract you want to deploy and set the parameters. Usually, you don't need to set them manually, just click Estimate and the parameters will be set automatically. Then click Deploy and it will call up a wallet popup to confirm and send the deployment transaction. (Make sure you have some CFX in your account to pay for the gas fee and storage fee)

![](../images/chainide/deploy-popup.png)

The contract is successfully deployed when the transaction is packed and executed. The compilation and deployment process of the contract is visible in the Logger window. All sent transactions are visible in the `Transaction` plugin. And we can check the details of the transaction in ConfluxScan by clicking the transaction link.

![](../images/chainide/deploy-success.jpeg)

After the contract is deployed, we can also interact with the contract directly in the Deploy & Interaction plugin. It displays all deployed contracts and their addresses, with all the methods listed under each contract:

<img src="../images/chainide/contract-interact-intro.jpeg" width="500px" />

There are two types of interactions. One is calling methods to query the status of the contract such as `owner`, `balanceOf` methods. Just Get with parameters for these methods to get the status of the contract directly.

The other one is used to change the status of the contract, which needs to be triggered by sending a transaction. After the parameters are set, request the wallet by clicking `Submit` to send the transaction. The contract status will change only after the transaction is executed successfully.

In ChainIDE, the first method is shown by a green icon, and the second one is shown by a yellow icon.

This contract example implements a simple token. The owner of the contract can `mint` new tokens to anyone, and anyone can `transfer` their token to others.

## Reference

* [solidity-by-example](https://solidity-by-example.org/)